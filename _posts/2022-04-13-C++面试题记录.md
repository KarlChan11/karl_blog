## 一.区别new-delete / malloc-free:
   1. `new-delete` 是C++的运算符，`malloc-free` 是C++/C的标准库函数 
   1. 对于非内建数据类型对象在构造时需要调用构造函数，对象析构时需要调用析构函数，`malloc-free`是库函数不在编译器控制权限内做不到<br>
   **所以C++提供`new-delete`运算符。**
   
## 二.delete与 delete []区别：
   - `delete` 只调用一次析构函数，`delete[]`调用每个成员的析构函数.
   - 对于内建数据类型来说，用哪个效果一样。但是自定义的复杂数据类型不能混用
   
## 三.C++有哪些特性（面向对象特性）：
   ***封装、继承、多态***
   
## 四.子类析构要调用父类的析构吗：
   - 对象创建时，首先调用父类构造函数，接着调用子类构造函数
   - 对象销毁时，先调用子类的析构函数，在调用父类的析构函数
   
## 五.多态、虚函数、纯虚函数：
   - 多态：不同对象根据同一消息产生不通动作。
   - 分编译期多态和运行期多态
   - 编译期多态-函数和运算符的重载 
   - 运行期多态-虚函数
   - 虚函数：`virtual `，本类实现，子类可重新实现它
   - 纯虚函数：`virtual void fun（）= 0;` 只定义接口，子类实现。
   - 有一个纯虚函数的话不能定义对象。-抽象类 
   
## 六.求下面函数的返回值（微软）
```c++
int func(x) { 
    int countx = 0; 
    while(x) { 
    countx ++; 
    x = x&(x-1); 
    } 
    return countx; 
} 
```
假定`x = 9999`。 答案：8 \
思路：将x转化为2进制，看含有的1的个数。

## 七.什么是"引用"？声明和使用"引用"要注意哪些问题:
  - 别名。操作引用相当于对变量直接操作。声明引用必须初始化。不占存储空间，不能对数组建立引用
   
## 八.将"引用"作为函数参数有哪些特点:
- 与传指针效果一样。别名来使用
- 引用传递内存中不产生实参副本，直接调用形参
- 指针也要产生副本。引用更清晰
   
## 九.常引用：
- 函数传参既要用引用比较高效，又要保护变量不被函数修改修改时

## 十.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?：
  - 格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }
  - 好处：不产生被返回值的副本
  - 注意：不能产生局部变量的引用，生命周期在函数返回时被销毁了。不能返回new局部变量，产生泄露。\
  可返回类成员的引用，最好是常引用，const
  
## 十一.结构与联合有和区别？
  - 内存:结构内各个变量各自占有内存,联合内所有成员共享内存
  - 数据:对结构内的变量修改值互相之间不影响,对联合内的成员修改值,值会覆盖
  
## 十二.重载（`overload`)和重写(`overried`，有的书也叫做“覆盖”）的区别？
  - 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
  - 重写：是指子类重新定义父类虚函数的方法 \
  - 从实现原理上来说：
    - 重载 早绑定，编译器修饰函数，其实也是不同的函数。
    - 重写：晚绑定，子类重现父类的虚函数，父类指针指向不同子类对象指针，动态调用子类的函数

## 十三.有哪几种情况只能用intialization list 而不能用assignment?
- 答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。构造函数之前调用

## 十四. C++是不是类型安全的？
- 答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

## 十五. main 函数执行以前，还会执行什么代码？
- 答案：全局对象的构造函数会在main 函数之前执行。

## 十六。内存分配方式：
  1. 静态存储区： `static `和 *全局变量*。生命周期最长，为程序的运行生命周期都存在。
  2. 栈：函数的局部变量，函数返回时，自动回收
  3. 堆：动态内存分配。`new malloc` 。生存期由程序员决定。需手动释放。
  
## 十七.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
```c++
   BOOL: if（a）
   int:  if（0==a）
   float: const float EXP = 0.000001;
           if（a >= -EXP）&&（a <= EXP）
   *: if（a == nullptr）
```
   
## 19.请说出`const`与`#define` 相比，有何优点？
  - `Const`: 定义常量，修饰函数形参，修饰函数返回值。被修饰的变量受到保护，提高程序稳健性
  - `const` 常量与 `#define`： `const`有类型检查，`#define`是字符串替换 

## 20.简述数组与指针的区别？
数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
- (1)修改内容上的差别
```c++
char a[] = "hello"; 
a[0] = 'X';
char *p = "world";// 注意p 指向常量字符串
p[0] = 'X'; // 编译器不能发现该错误，运行时错误
```
- (2) 用运算符`sizeof` 可以计算出数组的容量（字节数。
  `sizeof(p)`,`p `为指针得到的是一个指针变量的字节数，而不是`p `所指的内存容量。 <br>
    `C++/C` 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br>
    ```c++
    char a[] = "hello world";
    char *p = a;
    cout<< sizeof(a) << endl; // 12 字节
    cout<< sizeof(p) << endl; // 4 字节

    ```
- 计算数组和指针的内存容量
    ```c++
        void Func(char a[100])
        {
        cout<< sizeof(a) << endl; // 4 字节而不是100 字节
        }
    ```
## 21： int (*s[10])(int) 表示的是什么？
`int (*s[10])(int)` **函数指针数组**，每个指针指向一个`int func(int param)`的函数。

## 22：栈内存与文字常量区
   ```c++
    char str1[] = "abc";
    char str2[] = "abc";

    const char str3[] = "abc";
    const char str4[] = "abc";

    const char *str5 = "abc";
    const char *str6 = "abc";

    char *str7 = "abc";
    char *str8 = "abc";

    cout << ( str1 == str2 ) << endl;//0  分别指向各自的栈内存
    cout << ( str3 == str4 ) << endl;//0  分别指向各自的栈内存
    cout << ( str5 == str6 ) << endl;//1指向文字常量区地址相同
    cout << ( str7 == str8 ) << endl;//1指向文字常量区地址相同
```
结果是：0 0 1 1 <br>
解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域
  
## 23题：将程序跳转到指定内存地址
要对绝对地址`0x100000`赋值，我们可以用`(unsigned int*)0x100000 = 1234;`
那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
```c
　　*((void (*)( ))0x100000 ) ( );
　　首先要将0x100000强制转换成函数指针,即:
　　(void (*)())0x100000
　　然后再调用它:
　　*((void (*)())0x100000)();
　　用typedef可以看得更直观些:
　　typedef void(*)() voidFuncPtr;
　　*((voidFuncPtr)0x100000)();
  ```
## 24题：`int id[sizeof(unsigned long)];`这个对吗？为什么？
 - 答案:正确 这个 `sizeof`是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量。

 ## 25题：引用与指针有什么区别？
- 【参考答案】                         
1. 引用必须被初始化，指针不必。
1. 引用初始化以后不能被改变，指针可以改变所指的对象。
1. 不存在指向空值的引用，但是存在指向空值的指针。


## 26题：const  与 #define 的比较 ，const有什么优点?
- 【参考答案】
 1. `const `常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应)

 1.  有些集成化的调试工具可以对` const `常量进行调试，但是不能对宏常量进行调试。

## 30题：全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
- 生命周期不同：\
全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
- 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。
- 操作系统和编译器通过内存分配的*位置*来知道的，全局变量分配在*全局数据段*并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。
- 内存：
　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

  1. 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

  2. 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

  3. 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

  4. 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

  5. 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
